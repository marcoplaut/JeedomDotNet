using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Text;

namespace JeedomDotNet
{
    public class Jeedom
    {
        public Plugins Plugins;
        public Commands Commands;
        public Messages Messages;

        public enum ScenarioType
        {
            Start,
            Stop,
            Enable,
            Disable
        }

        /// <summary>
        /// Jeedom URL generated by the library
        /// </summary>
        public string URL
        {
            get { return this._url; }
        }

        /// <summary>
        /// IP adress or domain name
        /// </summary>
        public string Host
        {
            get { return this._host; }
            set {
                this._host = value;
                this.Reload();
               }
        }

        /// <summary>
        /// Port used for Jeedom connection
        /// Standard port is 80 for HTTP and 443 for HTTPS
        /// </summary>
        public int Port
        {
            get { return this._port; }
            set {
                this._port = value;
                this.Reload();
            }
        }

        /// <summary>
        /// The API key generated by Jeedom
        /// </summary>
        public string API_Key
        {
            get { return this._api_key; }
            set { this._api_key = value; }
        }

        /// <summary>
        /// Specify if Jeedom is accessible trough a HTTPS connection
        /// </summary>
        public bool UseSSL
        {
            get { return this._usessl; }
            set {
                this._usessl = value;
                this.Reload();
            }
        }

        /// <summary>
        /// Disable SSL certificate verification when it is self-signed
        /// Works only with UseSSL defined to true
        /// </summary>
        public bool AllowSelfSignedCertificate
        {
            get { return this._allowSelfSignedCert; }
            set {
                this._allowSelfSignedCert = value; }
        }

        private string _url;
        private string _host;
        private int _port;
        private string _api_key;
        private bool _usessl;
        private bool _allowSelfSignedCert;

        /// <summary>
        /// Entry point of the Jeedom API
        /// </summary>
        /// <param name="host">IP adress or domain name</param>
        /// <param name="apiKey">The API key generated by Jeedom</param>
        /// <param name="usessl">Specify if Jeedom is accessible trough a HTTPS connection</param>
        /// <param name="allow_self_signed_cert">Disable SSL certificate verification when it is self-signed
        /// Works only with usessl defined to true</param>
        public Jeedom(string host, string apiKey, bool usessl = false, bool allow_self_signed_cert = false)
        {
            this._host = host;
            this._api_key = apiKey;
            this._usessl = usessl;
            this._allowSelfSignedCert = allow_self_signed_cert;

            if (this._usessl)
                this._port = 443;
            else
                this._port = 80;

            this.Init();
        }

        /// <summary>
        /// Entry point of the Jeedom API
        /// </summary>
        /// <param name="host">IP adress or domain name</param>
        /// <param name="port">Port used for Jeedom connection
        /// Standard port is 80 for HTTP and 443 for HTTPS</param>
        /// <param name="apiKey">The API key generated by Jeedom</param>
        /// <param name="usessl">Specify if Jeedom is accessible trough a HTTPS connection</param>
        /// <param name="allow_self_signed_cert">Disable SSL certificate verification when it is self-signed
        /// Works only with usessl defined to true</param>
        public Jeedom(string host, int port, string apiKey, bool usessl = false, bool allow_self_signed_cert = false)
        {
            this._host = host;
            this._port = port;
            this._api_key = apiKey;
            this._usessl = usessl;
            this._allowSelfSignedCert = allow_self_signed_cert;

            this.Init();
        }

        /// <summary>
        /// Initialise the connection string and sets up Jeedom variables
        /// </summary>
        private void Init()
        {
            _url = new UriBuilder(_usessl ? "https" : "http", _host, _port, "/core/api/jeeApi.php").ToString();

            this.Commands = new Commands(this);
            this.Plugins = new Plugins(this);
            this.Messages = new Messages(this);
        }

        /// <summary>
        /// Reinitialise the jeedom variables
        /// </summary>
        public void Reload()
        {
            this.Init();
        }

        /// <summary>
        /// Send a ping to the Jeedom controler
        /// </summary>
        /// <returns>True if Jeedom answers
        /// If not false</returns>
        public bool Ping()
        {
            string result = RPCCommand("ping");

            JObject googleSearch = JObject.Parse(result);

            IEnumerable<JToken> results = googleSearch["result"];

            return (results.ToString() == "pong");
        }


        /// <summary>
        /// Get the Jeedom version
        /// </summary>
        /// <returns>Jeedom version</returns>
        public string GetVersion()
        {
            string result = RPCCommand("version");

            JObject googleSearch = JObject.Parse(result);

            IEnumerable<JToken> results = googleSearch["result"];

            return results.ToString();
        }

        public string Scenario(int id, ScenarioType scenario)
        {
            string action = "";

            switch (scenario)
            {
                case ScenarioType.Disable:
                    action = "deactivate";
                    break;

                case ScenarioType.Enable:
                    action = "activate";
                    break;

                case ScenarioType.Start:
                    action = "start";
                    break;

                case ScenarioType.Stop:
                    action = "stop";
                    break;
            }

            Dictionary<string, object> command = new Dictionary<string, object>()
            {
                { "apikey", this.API_Key },
                { "type", "scenario" },
                { "action", action },
                { "id", id }
            };

            return Query(command);
        }

        public string Command(int id)
        {
            Dictionary<string, object> command = new Dictionary<string, object>()
            {
                { "apikey", this.API_Key },
                { "type", "cmd" },
                { "id", id }
            };

            return Query(command);
        }

        public Command GetCommand(int id)
        {
            string result = RPCCommand("cmd::byId", new Dictionary<string, object>() { { "id", id } });

            JObject googleSearch = JObject.Parse(result);

            IEnumerable<JToken> results = googleSearch["result"];

            return JsonConvert.DeserializeObject<Command>(results.ToString());
        }

        /// <summary>
        /// Send an RPC command to the Jeedom controler
        /// </summary>
        /// <param name="method">The method name to call</param>
        /// <returns>TODO</returns>
        public string RPCCommand(string method)
        {
            return RPCCommand(method, new Dictionary<string, object>());
        }

        /// <summary>
        /// Send an RPC command to the Jeedom controler
        /// </summary>
        /// <param name="method">The method name to call</param>
        /// <param name="vars">A [string, object] dictionnary that contains variables to send to the Jeedom controler</param>
        /// <returns>TODO</returns>
        public string RPCCommand(string method, Dictionary<string, object> vars)
        {
            // Our RPC command "object"
            Dictionary<string, object> request = new Dictionary<string, object>()
            {
                { "jsonrpc", "2.0" },
                { "id", new Random().Next(1,9999) },
                { "method", method },
                { "params", vars }
            };

            // We inject the API key in the command parameters
            Dictionary<string, object> par = (Dictionary<string, object>)request["params"];
            par.Add("apikey", this.API_Key);

            // Our RPC command is encapsulated by JSON...
            Dictionary<string, object> command = new Dictionary<string, object>()
            {
                { "request", JsonConvert.SerializeObject(request) }
            };

            // And send by POST request to the Jeedom controler
            string result = Query(command);

            // Write the command result to Visual Studio
            Debug.Print(result);

            return result;
        }

        /// <summary>
        /// Execute a POST request to the Jeedom controler
        /// </summary>
        /// <param name="args">A [string, object] dictionnary that contains variables to send to the Jeedom controler</param>
        /// <returns>TODO</returns>
        private string Query(Dictionary<string, object> args)
        {
            // Formatting the POST request using HttpBuildQueryHelper
            // Thanks Roland Mai !!!
            string mystring = HttpBuildQueryHelper.FormatDictionary(args);

            // Our response string
            string response = string.Empty;

            try
            {
                byte[] byteArray = Encoding.UTF8.GetBytes(mystring);

                // Certificate verification need to be disabled when we use a self-signed certificate
                // If not an exception occurs
                if (_allowSelfSignedCert)
                    ServicePointManager.ServerCertificateValidationCallback = new System.Net.Security.RemoteCertificateValidationCallback(AcceptAllCertifications);

                HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(this._url);
                webRequest.Method = "POST";
                webRequest.ContentType = "application/x-www-form-urlencoded";
                webRequest.ContentLength = byteArray.Length;


                // Sending our POST request
                using (Stream webpageStream = webRequest.GetRequestStream())
                {
                    webpageStream.Write(byteArray, 0, byteArray.Length);
                }

                // Reading the response
                using (HttpWebResponse webResponse = (HttpWebResponse)webRequest.GetResponse())
                {
                    using (StreamReader reader = new StreamReader(webResponse.GetResponseStream()))
                    {
                        response = reader.ReadToEnd();
                    }
                }
            }
            catch (Exception ex)
            {
                // Write output to Visual Studio
                Debug.Write(ex.Message);
            }

            return response;
        }

        /// <summary>
        /// Callback that bypass SSL certificate verification
        /// Usefull when you use a self-signed certificate
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="certification"></param>
        /// <param name="chain"></param>
        /// <param name="sslPolicyErrors"></param>
        /// <returns></returns>
        private bool AcceptAllCertifications(object sender, System.Security.Cryptography.X509Certificates.X509Certificate certification, System.Security.Cryptography.X509Certificates.X509Chain chain, System.Net.Security.SslPolicyErrors sslPolicyErrors)
        {
            return true;
        }
    }
}
